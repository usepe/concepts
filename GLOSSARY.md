# Glosary

## B

#### <a href="#boy-scout-rule"></a>Boy-scout Rule

See [Litter-Pickup Refactoring](#litter-pickup-refactoring)

## C

#### <a href="#comprehension-refactoring"></a>Comprehension Refactoring

Similar to [Litter-Pickup Refactoring](#litter-pickup-refactoring). Both require a refactoring, but one comes from smelly code, the other is coming from need to comprehension.

## D

#### <a href="#design-stamina-hypothesis"></a>Design Stamina Hypothesis

The longer you keep not paying atention to your design on your system, the longer it will take to make changes on it.

## L

#### <a href="#litter-pickup-refactoring"></a>Litter-Pickup Refactoring

Always leave the code better than when you found it rule (a.k.a **boy-scout rule**)

Perform minor refactoring on code that you are working on to find it better the next time you have to dive into it.

#### <a href="#liskov-substitution-principle"></a>Liskov Substitution  Principle

Is a design principle part of [SOLID](#solid). States that any implementation of a class should be able to be changed by another implementation of the same type. In other words if the unit of code has the same interface implemented you should be able to interchange it without worrying about implementation details.

#### <a href="#long-term-refactoring"></a>Long-Term Refactoring

Kind of a planned refactoring, but that uses the other approaches to break down with a long-term plan in place.

The best of it is that let you pivot if needed, and learn from each gradual step.

## O

#### <a href="#open-closed-principle"></a> Open/Closed Principle

Is a design principle part of [SOLID](#solid). States that all classes (or any single unit of code) should be open for extension but closed from modification. In other words, once accepted a contract with the outside, that contract should remain unchanged if a new feature/improvement is needed.

## P

#### <a href="#planned-refactoring"></a> Planned Refactoring

Refactoring that takes place on code that was leaved unmantained, or without applying refactoring, for long period of times and is included in the agenda of changes as "Need to refactor this".

It is a good advice to not do this kind of refactorings unless they cannot be avoided, as they are hard to justify.

#### <a href="#preparatory-refactoring"></a> Preparatory Refactoring

Refactoring that takes place to add a new feature when the existent code base is not a good fit.

## S

#### <a href="#single-responsibility-principle"></a> Single Responsibility Principle

Is a design principle part of [SOLID](#solid). States that a class (or any single unit of code) should have only one responsibility and therefore only one reason to change.
